---
layout: post
title:  "23083. 꿀벌 승연이"
date:   2023-09-03 21:00:00 +0900
categories: [Algorithm, IUPC 2021]
use_math: true
---

링크: https://www.acmicpc.net/problem/23083

<br/>

# 1. 벌집을 그래프로 나타내기

문제에 의하면 짝수 번째 열의 칸은 홀수 번째 열의 칸보다 **반 칸** 아래에 위치해 있다라고 되어있다.

인덱스는 0 이상의 정수이므로 이를 그래프로 나타내기 위해서는 체크 무늬식으로 그래프를 정의하면 된다.

예를 들어, 예시에 있는 3행 4열의 크기를 가진 벌집의 경우 아래와 같이 나타낼 수 있다.

![23083-1](https://github.com/lspc678/lspc678.github.io/assets/79794123/a5241bfd-2582-44b8-bc98-8972b46f3336)

이동할 수 있는 칸(방 칸)은 검정색 칸으로 표시하였고, 이동할 수 없는 칸(구멍 칸)은 빨간색 칸으로 표시하였다.

그림에서 알 수 있듯이 3행 4열의 크기를 가진 벌집은 6행 4열의 그래프로 나타낼 수 있다.

즉, 그래프로 나타낼 경우 (그래프의 행의 개수) = (벌집의 행의 개수 * 2)이며 (그래프의 열의 개수) = (벌집의 열의 개수)이다.

그리고 홀수 번째 열에서는 홀수 번째 행만 사용하며 짝수 번째 열에서는 짝수 번째 행만 사용한다.

따라서, 벌집에서 $N$행 $M$열에 해당하는 칸을 그래프로 가져올 때 $M$이 홀수인지 짝수인지 구분해야 한다.

* $M$이 홀수 --> 그래프에서는 $(2N - 1)$행, $M$열에 해당
* $M$이 짝수 --> 그래프에서는 $(2N)$행, $M$열에 해당

<br/>

# 2. 각 칸으로 이동할 수 있는 경우의 수 알아내기

문제에 의하면 각 칸애서 이동할 수 있는 칸은 아래쪽, 오른쪽 위, 오른쪽 아래에 있는 칸이다. 따라서, 하나의 칸에는 최대 3군데의 입구가 존재한다.

예를 들어, 4행 2열의 경우 아래와 같이 입구가 3개 있는 것을 알 수 있다.

![23083-2](https://github.com/lspc678/lspc678.github.io/assets/79794123/bf0ec093-0bb1-45c3-8137-9c16c18e7cd9)

물론 경우에 따라 입구가 이보다 더 적을 수 있다. 

이를 일반화하여 $i$행 $j$열 칸에 도달할 수 있는 경우의 수를 $P(i, j)$라고 하자. 그러면 아래와 같은 식이 성립한다.

$P(i, j) = P(i - 2, j) + P(i - 1, j - 1) + P(i + 1, j - 1)$

여기에서 인덱스를 벗어나거나 구멍 칸인 경우에는 $0$으로 처리하면 된다.

즉, 이 문제는 Dynamic Programming으로 해결할 수 있다.

<br/>

# 3. 1열에 있는 칸 처리

위에서 구현한 그래프에서 1열에 있는 칸의 경우 입구가 1개(위 쪽) 밖에 없다. 따라서, 1열에 있는 칸부터 경우의 수를 고려한다.

우선 1행 1열에 도달할 수 있는 경우의 수는 $1$이다. 그리고 아래쪽으로 내려가면서 구멍 칸이 아니면 경우의 수는 $1$이다. 

![23083-3](https://github.com/lspc678/lspc678.github.io/assets/79794123/54a4a83a-6e51-4e45-9b41-969fdd5bea21)

그러나 구멍 칸을 만나게 되면 그 이후에 있는 칸에는 도달할 수 없으므로 경우의 수는 전부 $0$이 된다.

![23083-4](https://github.com/lspc678/lspc678.github.io/assets/79794123/1ad652bc-73e7-464c-81eb-5176a17e971e)

여기에서 주의할 점은 아래쪽으로 내려갈 때 행의 번호가 **2씩 증가**한다는 것이다. 즉, 1행 1열의 아래칸은 3행 1열이다. (2행 1열이 아니다)

<br/>

# 4. 점화식 적용

각 칸에 대하여 위쪽, 왼쪽 위, 왼쪽 아래 칸에 있는 숫자를 모두 더한다. 왼쪽 위, 왼쪽 아래 칸에 있는 숫자를 더해야 하므로 2열 맨 위에서부터 시작해서 아래 방향으로 처리하는 것이 좋다.

예시에 있는 그래프를 기준으로 2열에 있는 칸을 모두 채우면 다음과 같다.

![23083-5](https://github.com/lspc678/lspc678.github.io/assets/79794123/4ba771a2-ad7b-451e-9b82-bf1a81cbadcf)

2행 2열, 4행 2열, 6행 2열로 가는 경우의 수는 아래와 같이 구할 수 있다.

$P(2, 2) = P(1, 1) + P(3, 1) = 2$ <br/>
$P(4, 2) = P(2, 2) + P(3, 1) + P(5, 1) = 4$ <br/>
$P(6, 2) = P(4, 2) + P(5, 1) = 5$ <br/>

이러한 방식으로 3열, 4열을 순서대로 채우면 된다. 이렇게 모든 칸을 채우면 아래와 같이 문제에 대한 정답을 구할 수 있다.

![23083-6](https://github.com/lspc678/lspc678.github.io/assets/79794123/6f2a5e40-638f-4279-af11-c7582bbb37ff)

문제에서 $N$행 $M$열까지 이동하는 경우의 수를 구하라고 했으므로 그래프에서 맨 오른쪽 아래에 있는 칸에 적혀있는 숫자가 답이 된다. 예시에서는 $P(6, 4) = 20$이므로 답은 $20$이 된다.

<br/>

# 5. 전체 코드
```cpp
#include <iostream>
#include <vector>

typedef long long ll;
const ll MOD = 1000000007LL;

int main()
{
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);
	std::cout.tie(NULL);

	ll N, M;
	std::cin >> N >> M;

	std::vector<std::vector<ll>> v(2 * N + 1, std::vector<ll>(M + 1, 0LL)); 
    // 행의 개수가 2N(개)이고 열의 개수가 M(개)인 2차원 벡터 생성

	int K;
	std::cin >> K;

	for (int i = 0; i < K; i++)
	{
		ll row, col;
		std::cin >> row >> col;

        // 홀수 번째 열인지 짝수 번째 열인지에 따라 행의 번호가 달라짐
		if (col % 2 == 1)
			v[2 * row - 1][col] = -1; // 구멍칸은 -1로 처리
		else
			v[2 * row][col] = -1; // 구멍칸은 -1로 처리
	}

	v[1][1] = 1; // 1행 1열은 경우의 수가 1임

	for (ll row = 2; row <= N; row++)
	{
		if (v[2 * row - 1][1] != -1)
		{
			if (v[2 * row - 3][1] == 1)
				v[2 * row - 1][1] = 1;
			else
				v[2 * row - 1][1] = 0;
		}
	}
	
	for (ll col = 2; col <= M; col++)
	{
		if (col % 2 == 1)
		{
			for (ll row = 1; row <= N; row++)
			{
				if (v[2 * row - 1][col] == -1) 
					continue; // 현재 칸이 구멍 칸일 경우 건너뜀

				ll c1 = 0LL;
				ll c2 = 0LL;
				ll c3 = 0LL;

                // 위쪽 칸 확인
				if ((row != 1) && (v[2 * row - 3][col] != -1))
					c1 = v[2 * row - 3][col];

                // 왼쪽 아래 칸 확인
				if ((row != 1) && (v[2 * row - 2][col - 1] != -1))
					c2 = v[2 * row - 2][col - 1];

                // 왼쪽 위 칸 확인
				if (v[2 * row][col - 1] != -1)
					c3 = v[2 * row][col - 1];

				v[2 * row - 1][col] = (c1 + c2 + c3) % MOD;
			}
		}
		else
		{
			for (ll row = 1; row <= N; row++)
			{
				if (v[2 * row][col] == -1) 
					continue; // 현재 칸이 구멍 칸일 경우 건너뜀

				ll c1 = 0LL;
				ll c2 = 0LL;
				ll c3 = 0LL;

                // 위쪽 칸 확인
				if ((row != 1) && (v[2 * row - 2][col] != -1))
					c1 = v[2 * row - 2][col];

                // 왼쪽 아래 칸 확인
				if (v[2 * row - 1][col - 1] != -1)
					c2 = v[2 * row - 1][col - 1];

                // 왼쪽 위 칸 확인
				if ((row != N) && (v[2 * row + 1][col - 1] != -1))
					c3 = v[2 * row + 1][col - 1];

				v[2 * row][col] = (c1 + c2 + c3) % MOD;
			}
		}
	}

	if (M % 2 == 1)
		std::cout << v[2 * N - 1][M] << "\n";
	else
		std::cout << v[2 * N][M] << "\n";

	return 0;
}
```
